package main

import (
	"fmt"
	"sync"
	"time"
)

/*
 Задача:
 Реализовать конкурентную запись данных в map.

 Есть два метода как это можно сделать.
	1) С помощью sync.Map
	2) C помощбю sync.Mutex и обычной Map

 С помощью sync.Map. Единственный недостаток - это когда повышенное количество записей.
 С помощбю sync.Mutex и обычной Map. Больше возможностей - больше ответственность.
*/

/*
Логика работы. Есть sync.Map любые действия контролируются данной реализацией.
Ничего реализовывать самому не надо. Используется как обычная мапа, но с своими плюсами и минусами
*/
func Test_7_1() {

	//Создаем Мапу. Мапа данного типа использует интерфейсы, что более интересно, но менее типобезопасно.
	var sm sync.Map

	// Запускаем несколько горутин для записи в map
	for i := 0; i < 10; i++ {
		go func(n int) {
			key := fmt.Sprintf("key%d", n)
			sm.Store(key, n)
		}(i)
	}

	// Ждем, чтобы горутины завершили свою работу
	// для примера
	time.Sleep(time.Second)

	// Чтение значений
	sm.Range(func(key, value interface{}) bool {
		fmt.Println(key, value)
		return true
	})
}

/*
Логика работы. Используется примитив, чтобы блокировать запись в мапу.
Когда мьютекс заблокирован, то никто и ничто не сможет совершать действия, если стоит запрос на блокироку.
То есть, если мьютекс заблокирован, а мы пытаемся снова его заблокировать для своих действий,
то система будет ждать разблокировки и только потом заблокирует снова мьютекс и тд
*/
func Test_7_2() {
	// Объявляем примитив синхронизации
	var mutex sync.Mutex
	// объявляем обыную мапу
	m := make(map[string]int)

	// Запускаем несколько горутин для записи в map
	for i := 0; i < 10; i++ {
		go func(n int) {
			key := fmt.Sprintf("key%d", n)

			// Блокируем мьютекс перед записью в map
			mutex.Lock()
			//ЗДесь может быть любая логика. В нашем случае запись.
			// Пока залочен. никто и ничто не может изменять мапу
			m[key] = n

			//Разлок мьютекса
			mutex.Unlock()
		}(i)
	}

	// Ждем, чтобы горутины завершили свою работу
	// для примера
	time.Sleep(time.Second)

	// Блокируем мьютекс перед чтением из map
	mutex.Lock()
	for k, v := range m {
		fmt.Println(k, v)
	}
	mutex.Unlock()
}
