
Вопрос 1.
Какой самый эффективный способ конкатенации строк?

В зависимости от количества действий. Если действий, связанных со строками и их объединением, будет всего 1 или 2, то оптимальным решением будет использовать +.
Если количество постоянных действий превышает 2, то целесообразнее использовать strings.Join, так как он оптимизирован для уменьшения количества необходимых 
аллокаций памяти. Если вся работа полностью завязана на строках, то предпочтительнее будет использовать strings.Builder.


Вопрос 2. 
Что такое интерфейсы, как они применяются в Go?

Интерфейс в Go — это набор методов (сигнатур), но он сам по себе не реализует эти методы. Вместо этого, он определяет набор методов, которые тип должен
реализовать. Любой тип, который реализует все методы интерфейса, автоматически считается реализующим этот интерфейс. Основное применение интерфейса 
заключается в возможности абстрагировать решения друг от друга. За счет контрактов строится обещание реализации и возможность использования разных реализаций
без прямой привязки к одной.


Вопрос 3.
Чем отличаются RWMutex от Mutex?

Mutex - блокировка потока. Пока Mutex захватывает один поток, никто другой не получит к нему доступ, а вот когда RWMutex, то тут уже появляется возможность определения
чтение или запись. Что позволяет при блокировке получать доступ для чтения. 


Вопрос 4. 
Чем отличаются буферизированные и не буферизированные каналы?

Не буферизированные каналы - одна запись. Отправитель будет блокироваться пока запись не будет прочтина и получатель так же будет заблокирован. 
буферизированные каналы позволяют работать после отправки отправителем до момента заполнения буфера. 


Вопрос 5.
Какой размер у структуры struct{}{}? - 0 байт


Вопрос 6.
Есть ли в Go перегрузка методов или операторов? - нет, это одна из ключевых особенностей


Вопрос 7.
В какой последовательности будут выведены элементы map[int]int? - в рандомной, так как иттерация по мапе происходит в случайном порядке
Пример:
m[0]=1
m[1]=124
m[2]=281 


Вопрос 8.
В чем разница make и new?

new(T) - создает указатель на Т и Т является нулвым значением 
Функция make используется только для создания слайсов, карт и каналов и возвращает инициализированный (не нулевой) экземпляр типа, а не указатель.


Вопрос 9.
Сколько существует способов задать переменную типа slice или map?
Slice:
s := make([]int, 5)
Создает слайс заданной длины и емкости.
Элементы инициализируются нулевыми значениями для данного типа
Позволяет указать емкость слайса, что полезно для улучшения производительности при последующих расширениях слайса

s := []int{1, 2, 3, 4, 5}
Создает слайс с начальным набором элементов, указанных в литерале
var s []int 
Создает nil-слайс, без выделения памяти
Пустой слайс имеет длину и емкость равную 0
arr := [5]int{1, 2, 3, 4, 5}
Создает слайс как "вид" на существующий массив или его часть.
Изменения в слайсе отражаются на соответствующих элементах массива и наоборот.
Длина слайса равна количеству элементов, указанных в срезе, а его емкость — количеству элементов от начала среза до конца массива.

Map:
Создает и инициализирует пустую карту с заданной начальной емкостью
Это наиболее часто используемый способ создания карты, когда требуется дальнейшее добавление элементов
Указание емкости полезно для оптимизации производительности, если известно примерное количество элементов, которые будут добавлены
m := make(map[string]int)
Создает карту с начальным набором ключ-значение, указанным в литерале.
Полезно, когда требуется карта с предопределенным набором данных.
m := map[string]int{"foo": 1, "bar": 2}
Создает nil-карту. В отличие от слайсов, nil-карты нельзя использовать для добавления элементов до их инициализации с помощью make или литерала карты.
Пустая карта имеет длину 0 и не выделяет память.
var m map[string]int


Вопрос 10.
Что выведет данная программа и почему?


func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

Ответ. Данная программа выдаст одинаковое сообщение. Связано это с тем, что мы  p = &b в переменной, а это значит, что у p копии в функции новые данные указывающие. 
Поэтому основная р не изменится. 


Вопрос 11.
Что выведет данная программа и почему?


func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

Ответ. Будет паника. Потому что мы передаем копию wg,а не указатель. поэтому изменения будут связаны с копией, а не основной wg. Из за чего будет вечное ожидание



Вопрос 12.
Что выведет данная программа и почему?


func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}


Ответ. В данном формате if true  анологичен просто {}, что создает область видимости дополнителньую. Следовательно изменения над n будут происходить
в не общей области видимости, поэтому ответ будет 0


Вопрос 13.
Что выведет данная программа и почему?


func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

Ответ. main выведет [100 2 3 4 5]. Слайсы передаются по указателю. поэтому первая позиция изменится и в основном слайде.
Но  v = append(v, b) создаст новый массив, поэтому ссылаться на основной он уже не будет

Вопрос 14.

Что выведет данная программа и почему?


func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

Ответ. Так как емкость 2, то при slice = append(slice, "a") создатся новый слайс, который к старому ни имеет ни какого отношения и ответ будетэ
["b", "b", "a"]
["a", "a"]