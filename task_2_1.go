package main

import (
	"fmt"
	"sync"
)

/*

	Написать программу, которая конкурентно рассчитает значение квадратов чисел взятых из массива (2,4,6,8,10) и
	выведет их квадраты в stdout.

	Данная реалиазация показывает работу с горутинами и каналами, но не учитывает вероятность роста количества рутин,
	а так же не использует повторно рутины, что приводит к затратам на инициализации.

	task_2_2 реализует пул горутин, который контролиурет работу и количество каналов
*/

func Task_2() {

	//Инициализиурем срез
	numbers := []int{2, 4, 6, 8, 10}

	//Инициализиурем канал
	//Для отправки резульатов обратно
	squares := make(chan int)

	//Инициализируем структуру
	//Для ожидания окончания всех горутин
	var wg sync.WaitGroup

	//Цикл для прохода по массиву
	for _, number := range numbers {
		//Добавляем дельту
		//Для увелечения количества известных рабочих горутин
		wg.Add(1)

		//Запускаем рутину
		//Для параллельного и конкурентного решения задачи
		go square(number, squares, &wg)
	}

	//Запускаем рутину
	//Для ожидания окончания работы всех горутин
	go func() {

		//Ожидаем, когда дельта станет 0
		wg.Wait()
		//Закрываем канал
		close(squares)
	}()

	//Считываем все сообщения из канала и выводим их
	for square := range squares {
		fmt.Println(square)
	}

}

// Функция для решения поставленной задачи
func square(number int, squares chan int, wg *sync.WaitGroup) {

	// после завершения работы  делаем декремент для дельты
	defer wg.Done()

	// отправляем в канал решения нашей задачи
	squares <- number * number
}
