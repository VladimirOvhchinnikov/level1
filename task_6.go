package main

import (
	"context"
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

/*
 Задача:
 Реализовать все возможные способы остановки выполнения горутины.

 Разобрав этот вопрос было определены такие способы закрытия рутин.
 Их распрделил  по частоте использвоания
*/

// Использование канала для сигналов остановки
// Это самый распространенный способ закрытие канала

// Логика работы
// В канал приходит сигнал, после чего происходит считывание и выход из цикла с помощью return
func version_1(stop <-chan struct{}) {
	for {
		select {
		// Ждем сигнал
		case <-stop:
			// Выходим из цикла
			return
			// Продолжаем работу
		default:

		}
	}
}

// Использование контекста для остановки
// Это оптимальная версия для работы с микросервисами. Потому что позволяет через функционал контекста
// координировать свои решения между слоями

// Логика работы
// Считывается контекст и получив сообщение о заакрытие. рутина останавливается
func version_2(ctx context.Context) {
	for {
		select {
		// Остановить работу и выйти
		case <-ctx.Done():

			return
		default:
		}
	}
}

// Использование закрытие канала для остановки
func version_3(ch <-chan struct{}) {
	for {
		select {
		case <-ch:
			return
		}
	}
}

// Использование таймаутов и тикеров
// Это оптимально, когда есть решения тесно взаимосвязанные с временем
func version_4() {
	timer := time.NewTimer(time.Second * 10)
	defer timer.Stop()

	for {
		select {
		case <-timer.C:
			return
		}
	}
}

// Использование атомарных операций
// Когда это использовать я так и не понял.
// Почему использовать такое решение, а не просто глоабльную переменную?
// Потому что использования глобальной переменной может привести к состоянию гонки или к проблемам видимости
// Как решает эту задачу данное решение?
// Пока действие над значением не будет завршено целиком, то никто не сможет увидеть промежуточное состояние

var running int32 = 1

func version_5() {
	// То есть, если везде будет такая релаизация, то это обеспечивает безопасность
	for atomic.LoadInt32(&running) == 1 {
	}
}

var wg sync.WaitGroup

func version_6(stop <-chan struct{}) {
	defer wg.Done()
	for {
		select {
		case <-stop:
			return
			// обычная работа горутины
		}
	}
	//wg.Add(1)
	//go doWork(stopChan)
	//wg.Wait() // Ожидание завершения

}

// Метод, который не принято использовать.
// Завершается по панике
func version_7() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("Recovered in doWork", r)
		}
	}()

}
