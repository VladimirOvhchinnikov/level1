package main

import (
	"fmt"
	"sync"
	"time"
)

/*
 Задача:
 Разработать программу, которая будет последовательно отправлять значения в канал,
 а с другой стороны канала — читать. По истечению N секунд программа должна завершаться.

 Причины такой реализации:
 - взятие структур и части логики из 4 задачи обусловлено идентичностью основных потребностей
 - объектное восприятие для человека часто проще,
 - возможность повторного использования - позволяет сократить расходы на инициализацию рутин и их закрытие

 Логика работы:
 - Есть канал. В него отправляются задачи
 - Есть работники. Они постоянно считывают и берут в работу задачи
 - Есть отправитель. Он постоянно отправялет работы

*/

// Структура работа.
// Может хранить любую информацию, которая характерезует суть абстрактной деятельности
// В моем случае - просто текст
type Job_5 struct {
	data string
}

// Структура работник.
// Может хранить любую информацию, которая характерезует суть абстрактного работника, но должна
// иметь номер индентифиактор, канал для считывания работ, структуру ожидания.
// В моем случае - только стандартные переменные
type Worker_5 struct {
	id   int
	jobs <-chan Job_5
	wg   *sync.WaitGroup
}

// Структура отправитель.
// Может хранить любую информацию, которая характерезует суть абстрактного отправителя, но должна
// иметь номер индентифиактор, канал для отправки работ
// В моем случае - только стандартные переменные
type Sender_5 struct {
	id   int
	jobs chan<- Job_5
}

// Функция-конструктор работника
func NewWorker_5(id int, jobs <-chan Job_5, wg *sync.WaitGroup) Worker_5 {
	return Worker_5{
		id:   id,
		jobs: jobs,
		wg:   wg,
	}
}

// Функция-конструктор отправителя
func NewSender_5(id int, jobs chan<- Job_5) Sender_5 {
	return Sender_5{
		id:   id,
		jobs: jobs,
	}
}

// Метод, который с определнным интервалом отправялет работу
func (se *Sender_5) Spammer(second time.Duration, count int) {

	//Запуск рутины
	go func() {

		//Цикл с определенным количеством иттераций
		for i := 0; i < count; i++ {

			//Отправка работы в канал
			se.jobs <- Job_5{data: "testy"}

			//остановка рутины
			time.Sleep(second)
		}

	}()
}

// Метод структуры Worker
// Запускает рутину для выполнения задач из канала jobs
func (w Worker_5) Start(stopChan <-chan struct{}) {

	//Зпуск рутины
	go func() {
		//Бесконечный цикл, пока не будет выполнено одно из условий закрытия
		for {
			//Два кейса
			// - когда закрытие происходит из за закрытия канала
			// - когда получен сигнал от канала stopChan
			select {
			case job, ok := <-w.jobs:
				if !ok {
					return // Канал закрыт, завершаем работу воркера
				}
				// Обработка задачи
				fmt.Println(job.data)
				w.wg.Done()
			case <-stopChan:
				fmt.Println("ctrl + c")
				return // Получен сигнал остановки, завершаем работу воркера
			}
		}
	}()
}

func Test_5() {

	// Продолжительность работы в секундах
	const N = 5
	// Количество сообщений для отправки
	const count = 10

	// Создаем канал для заданий
	jobs := make(chan Job_5)
	//Создаем канал для управления временем выполнения
	stopChan := make(chan struct{})
	var wg sync.WaitGroup = sync.WaitGroup{}

	// Создаем и запускаем воркер
	worker := NewWorker_5(1, jobs, &wg)
	worker.Start(stopChan)

	// Создаем и запускаем отправителя
	sender := NewSender_5(1, jobs)
	sender.Spammer(1*time.Second, count)

	// Запускаем таймер на N секунд
	time.AfterFunc(N*time.Second, func() {
		close(stopChan) // Посылаем сигнал остановки воркеру
		close(jobs)     // Закрываем канал jobs
	})

	// Ожидаем завершения всех задач
	wg.Add(count)
	wg.Wait()
}
